// ---------------------------------------------------------------------- 
// GENERATED FILE 
// All code in this file is generated by the SuperModels workbench 
// (version 5.0.0.1292). Any changes made to this file may lead to 
// incorrect behaviour and will be lost if the code is generated again. 
// Modify the model instead. 
// 
// Copyright : Sioux Technologies 
// Model     : Traffic.sms (Traffic) 
// Generator : C# state machine generator (Decomp1) 
// Source    : StartStop 
// ---------------------------------------------------------------------- 

// ReSharper disable IdentifierTypo
// ReSharper disable CheckNamespace
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantUsingDirective
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable ClassWithVirtualMembersNeverInherited.Global
// ReSharper disable UseObjectOrCollectionInitializer
// ReSharper disable once ClassNeverInstantiated.Global

#pragma warning disable CS8618

using System;
using System.Collections.Generic;
using InterfaceServices.ExceptionHandling;
using InterfaceServices.Model;
using ExtensionMethods;
using EventArgs = InterfaceServices.Model.EventArgs;

namespace Traffic.Generated.Interfaces;

public interface StartStop : IBaseInterface
{
    #region In events

    void Start(EventSource source);
    void Stop(EventSource source);

    #endregion

    public enum Events
    {
        Start = 0,
        Stop = 1
    }

    public enum States
    {
        Stopped = 0,
        Running = 1
    }
}

public class StartStopImpl : BaseInterface, StartStop
{

    public override ushort TypeId => 2;

    public override void Validate()
    {
        // Validate providing buffers
        __Validate(Provider);

        // Validate all client buffers
        MultiClientStrategy.GetAllClients().ForEach(__Validate);
    }


    #region In events
    public void Start(EventSource source)
    {
        if (!__Next(StartStop.Events.Start)) return;
        Provider.EventBuffer.Add(__BuildContext(StartStop.Events.Start, source), new EventId(Provider.PortName, StartStop.Events.Start), EventArgs.Empty());
    }

    public void Stop(EventSource source)
    {
        if (!__Next(StartStop.Events.Stop)) return;
        Provider.EventBuffer.Add(__BuildContext(StartStop.Events.Stop, source), new EventId(Provider.PortName, StartStop.Events.Stop), EventArgs.Empty());
    }

    #endregion
    
    #region State

    /// <inheritdoc />
    public override string ActiveStateName => ((StartStop.States)CurrentInterfaceState).ToString();
    public StartStop.States ActiveState => (StartStop.States)CurrentInterfaceState;

    #endregion

    #region internal

    /// <inheritdoc />
    protected override int CurrentInterfaceState { get; set; } = 0;

    /// <inheritdoc />
    protected override int[][] EventsMatrix { get; } =
    {
        new[] {1, 0}, // stopped
        new[] {1, 0} // running
    };

    /// <summary>
    /// This method keeps track of the interface state and determines whether the intended interface event is allowed
    /// in the current state of the interface.
    /// </summary>
    /// <param name="event">The intended event to execute.</param>
    /// <returns>True whether the event should be executed and be delivered at the receiver, false otherwise.
    /// </returns>
    /// <remarks>Generated method.</remarks>
    private bool __Next(StartStop.Events @event)
    {
        NextInterfaceState = EventsMatrix[CurrentInterfaceState][(int) @event];

        if (NextInterfaceState == -1)
        {
            var resolution = IllegalEventHandler.OnIllegalOutgoingEvent(
                GetType(),
                new IllegalEventArgs(
                    CurrentInterfaceState,
                    ((StartStop.States) CurrentInterfaceState).ToString(),
                    (int) @event,
                    @event.ToString()
                )
            );

            return resolution is IllegalEventResolution.Ignore;
        }

        CurrentInterfaceState = NextInterfaceState;
        return true;
    }

    /// <summary>
    /// This method validates and deals with illegal events in an eventNode (combination of an event buffer and port).
    /// </summary>
    /// <param name="node">The event node to validate</param>
    /// <remarks>Generated method.</remarks>
    private void __Validate(EventNode node)
    {
        var events = node.EventBuffer.GetEventsForPort<StartStop.Events>(node.PortName);
        foreach (var (eventId, @event) in events)
        {
            var valid = __Validate(@event, out var resolution);
            if (valid) break;

            if (resolution == IllegalEventResolution.Discard)
            {
                node.EventBuffer.Remove(eventId);
            }
        }
    }

    /// <summary>
    /// This method validates if a delivered event is valid.
    /// </summary>
    /// <param name="event">The intended event to execute.</param>
    /// <param name="resolution">The <see cref="IllegalEventResolution"> for an event, given the <see cref="CurrentInterfaceState">.</param>
    /// <returns>True if the event is valid, false otherwise.
    /// </returns>
    /// <remarks>Generated method.</remarks>
    private bool __Validate(StartStop.Events @event, out IllegalEventResolution resolution)
    {
        var nextInterfaceState = EventsMatrix[CurrentInterfaceState][(int) @event];

        resolution = IllegalEventResolution.Ignore;
        if (nextInterfaceState != -1) return true;

        resolution = IllegalEventHandler.OnIllegalDeliveredEvent(
            GetType(),
            new IllegalEventArgs(
                CurrentInterfaceState,
                ((StartStop.States)CurrentInterfaceState).ToString(),
                (int)@event,
                @event.ToString())
        );

        return resolution == IllegalEventResolution.Ignore;
    }

    /// <summary>
    /// Build context for an event including the source of the event.
    /// </summary>
    /// <param name="event">The intended event to execute.</param>
    /// <param name="source">The source of the event.</param>
    /// <remarks>Generated method.</remarks>
    private EventContext __BuildContext(StartStop.Events @event, EventSource source)
        => new(TypeId, (int)@event, source);

    #endregion
}

public static class StartStopExtensions
{
    #region In events

    public static void Start(this Port<StartStop> port) => port.Impl.Start(port.Source);
    public static void Stop(this Port<StartStop> port) => port.Impl.Stop(port.Source);

    #endregion
}
