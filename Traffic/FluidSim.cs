using MathNet.Numerics.LinearAlgebra.Double;
using PandISimComponents.Model;
using SimulatorsBase;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using PropertyView;
using Tools;
using ExtensionMethods;
using Tools.Helpers;
using UnitsNet.Units;
// ReSharper disable InconsistentNaming

// This file is (re) generated by the Supermodels workbench (Copyright Â© Sioux Technologies 2009 - 2024). Don't
// change it by hand. Change the model!

namespace Generated
{
    public partial class PandISimulator : INotifyPropertyChanged
    {
        private bool _showContentsText;
        public bool ShowContentsText
        {
            get => _showContentsText;
            set
            {
                _showContentsText = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("ShowContentsText"));
                foreach (var p in _pipes)
                    p.ShowContentsText = _showContentsText;
            }
        }
        public event PropertyChangedEventHandler PropertyChanged;

        #region P and I Model Elements

        public List<IElementBase> SimComponents { get; } = new();

        public PandISimulator()
        {
            _baseElements.Add(PS1);
            _baseElements.Add(PS2);
            _baseElements.Add(PS3);
            _baseElements.Add(PS4);
            _baseElements.Add(CarRed);
            _baseElements.Add(CarYellow);
            _baseElements.Add(CarGreen);
            _baseElements.Add(PedRed);
            _baseElements.Add(PedGreen);

            _junctions.ForEach(elm => SimComponents.Add(elm));

            InitPipes();
            _pipes.ForEach(elm => SimComponents.Add(elm));

            _baseElements.ForEach(elm => SimComponents.Add(elm));

            InitComponents(); // Add this method to the partial class to initialize resistances etc
            InitPostProcessingData();
        }

        public PressureSource PS1 { get; } = new() { ElementName = "PS1", Pressure = 2, FluidType = 1, Liquid = false, Temperature = 293.15, L = new CL() { SubC = new Dictionary<string, List<NM>>() {{ "V", new List<NM>() {new NM() { idx = -1, nm = "PS1.c60" },new NM() { idx = 0, nm = "p1" }}}}}, RhsFlowIndex = 7 };
        public PressureSource PS2 { get; } = new() { ElementName = "PS2", Pressure = 1, FluidType = 0, Liquid = false, Temperature = 293.15, L = new CL() { SubC = new Dictionary<string, List<NM>>() {{ "V", new List<NM>() {new NM() { idx = -1, nm = "PS2.c60" },new NM() { idx = 1, nm = "p4" }}}}}, RhsFlowIndex = 8 };
        public PressureSource PS3 { get; } = new() { ElementName = "PS3", Pressure = 2, FluidType = 1, Liquid = false, Temperature = 293.15, L = new CL() { SubC = new Dictionary<string, List<NM>>() {{ "V", new List<NM>() {new NM() { idx = -1, nm = "PS3.c60" },new NM() { idx = 2, nm = "p5" }}}}}, RhsFlowIndex = 9 };
        public PressureSource PS4 { get; } = new() { ElementName = "PS4", Pressure = 1, FluidType = 0, Liquid = false, Temperature = 293.15, L = new CL() { SubC = new Dictionary<string, List<NM>>() {{ "V", new List<NM>() {new NM() { idx = -1, nm = "PS4.c60" },new NM() { idx = 3, nm = "p7" }}}}}, RhsFlowIndex = 10 };
        public Valve CarRed { get; } = new() { ElementName = "CarRed", Id = 17, ManuallyOperated = false, NormallyOpen = false, L = new CL() { Map = new List<NM>() { new NM() { idx = 0, nm = "p1" },new NM() { idx = 4, nm = "p2" }}} };
        public Valve CarYellow { get; } = new() { ElementName = "CarYellow", Id = 18, ManuallyOperated = false, NormallyOpen = false, L = new CL() { Map = new List<NM>() { new NM() { idx = 4, nm = "p2" },new NM() { idx = 5, nm = "p3" }}} };
        public Valve CarGreen { get; } = new() { ElementName = "CarGreen", Id = 19, ManuallyOperated = false, NormallyOpen = false, L = new CL() { Map = new List<NM>() { new NM() { idx = 5, nm = "p3" },new NM() { idx = 1, nm = "p4" }}} };
        public Valve PedRed { get; } = new() { ElementName = "PedRed", Id = 20, ManuallyOperated = false, NormallyOpen = false, L = new CL() { Map = new List<NM>() { new NM() { idx = 2, nm = "p5" },new NM() { idx = 6, nm = "p6" }}} };
        public Valve PedGreen { get; } = new() { ElementName = "PedGreen", Id = 21, ManuallyOperated = false, NormallyOpen = false, L = new CL() { Map = new List<NM>() { new NM() { idx = 6, nm = "p6" },new NM() { idx = 3, nm = "p7" }}} };

        private Pipe[] _pipes;
        public Pipe[] Pipes => _pipes;

        private void InitPipes()
        {
            _pipes = new Pipe[]
            {
                new Pipe(0.005, 1, 10, 0.1, 293.15, 0) { ElementName="p1", Elements = new ElementConnection[] { new ElementConnection(PS1.V, ElementPort.Out), new ElementConnection(CarRed, ElementPort.In) } },
                new Pipe(0.005, 1, 10, 0.1, 293.15, 0) { ElementName="p2", Elements = new ElementConnection[] { new ElementConnection(CarRed, ElementPort.Out), new ElementConnection(CarYellow, ElementPort.In) } },
                new Pipe(0.005, 1, 10, 0.1, 293.15, 0) { ElementName="p3", Elements = new ElementConnection[] { new ElementConnection(CarYellow, ElementPort.Out), new ElementConnection(CarGreen, ElementPort.In) } },
                new Pipe(0.005, 1, 10, 0.1, 293.15, 0) { ElementName="p4", Elements = new ElementConnection[] { new ElementConnection(CarGreen, ElementPort.Out), new ElementConnection(PS2.V, ElementPort.Out) } },
                new Pipe(0.005, 1, 10, 0.1, 293.15, 0) { ElementName="p5", Elements = new ElementConnection[] { new ElementConnection(PS3.V, ElementPort.Out), new ElementConnection(PedRed, ElementPort.In) } },
                new Pipe(0.005, 1, 10, 0.1, 293.15, 0) { ElementName="p6", Elements = new ElementConnection[] { new ElementConnection(PedRed, ElementPort.Out), new ElementConnection(PedGreen, ElementPort.In) } },
                new Pipe(0.005, 1, 10, 0.1, 293.15, 0) { ElementName="p7", Elements = new ElementConnection[] { new ElementConnection(PedGreen, ElementPort.Out), new ElementConnection(PS4.V, ElementPort.Out) } },
            };
        }

        #endregion

        public void GetMatrixAndRhs(out DenseMatrix m, out DenseVector rhs_out)
        {
            const int size = 11;
            var matrix = new DenseMatrix(size, size);
            var rhs = new DenseVector(size);
            // Used for calculation:
            //   matrix[11,11] of Double precision (0-based)
            //   rhs[11] of Double precision (0-based)
            //   coefficient of Double precision
            // [ Ground node ]: PS1.V.Voltage, PS2.V.Voltage, PS3.V.Voltage, PS4.V.Voltage
            // [ Node 0   ]: PS1.V.Voltage, CarRed.Resistance
            // [ Node 1   ]: PS2.V.Voltage, CarGreen.Resistance
            // [ Node 2   ]: PS3.V.Voltage, PedRed.Resistance
            // [ Node 3   ]: PS4.V.Voltage, PedGreen.Resistance
            // [ Node 4   ]: CarRed.Resistance, CarYellow.Resistance
            // [ Node 5   ]: CarYellow.Resistance, CarGreen.Resistance
            // [ Node 6   ]: PedRed.Resistance, PedGreen.Resistance
            // Clear matrix
            matrix.Clear();
            rhs.Clear();
            // Fill matrix
            matrix[0,0] = 1.0 / CarRed.Resistance;
            matrix[0,4] = -(1.0 / CarRed.Resistance);
            matrix[0,7] = 1.0;
            matrix[7,0] = 1.0;
            matrix[1,1] = 1.0 / CarGreen.Resistance;
            matrix[1,5] = -(1.0 / CarGreen.Resistance);
            matrix[1,8] = 1.0;
            matrix[8,1] = 1.0;
            matrix[2,2] = 1.0 / PedRed.Resistance;
            matrix[2,6] = -(1.0 / PedRed.Resistance);
            matrix[2,9] = 1.0;
            matrix[9,2] = 1.0;
            matrix[3,3] = 1.0 / PedGreen.Resistance;
            matrix[3,6] = -(1.0 / PedGreen.Resistance);
            matrix[3,10] = 1.0;
            matrix[10,3] = 1.0;
            matrix[4,0] = -(1.0 / CarRed.Resistance);
            matrix[4,4] = 1.0 / CarRed.Resistance + 1.0 / CarYellow.Resistance;
            matrix[4,5] = -(1.0 / CarYellow.Resistance);
            matrix[5,1] = -(1.0 / CarGreen.Resistance);
            matrix[5,4] = -(1.0 / CarYellow.Resistance);
            matrix[5,5] = 1.0 / CarYellow.Resistance + 1.0 / CarGreen.Resistance;
            matrix[6,2] = -(1.0 / PedRed.Resistance);
            matrix[6,3] = -(1.0 / PedGreen.Resistance);
            matrix[6,6] = 1.0 / PedRed.Resistance + 1.0 / PedGreen.Resistance;
            rhs[7] = PS1.V.Voltage;
            rhs[8] = PS2.V.Voltage;
            rhs[9] = PS3.V.Voltage;
            rhs[10] = PS4.V.Voltage;
            // Distribute values
            m = matrix;
            rhs_out = rhs;
        }

        private static readonly List<(int row, int col)> PotentialNonzeroIndices = new List<(int row, int col)>
        {
            (0, 0),
            (0, 4),
            (0, 7),
            (7, 0),
            (1, 1),
            (1, 5),
            (1, 8),
            (8, 1),
            (2, 2),
            (2, 6),
            (2, 9),
            (9, 2),
            (3, 3),
            (3, 6),
            (3, 10),
            (10, 3),
            (4, 0),
            (4, 4),
            (4, 5),
            (5, 1),
            (5, 4),
            (5, 5),
            (6, 2),
            (6, 3),
            (6, 6),
        };

        public void Calculate(TimeSettings timeSettings)
        {
            var remainingTime = timeSettings.NominalStep.TotalSeconds;
            while (remainingTime > Constants.Epsilon)
            {
                SimComponents.ForEach(elm => elm.PrepareForCalculation());
                GetMatrixAndRhs(out var matrix, out var rhs);
                var y = SolveEquations(matrix, rhs, PotentialNonzeroIndices);

                // Implement in partial
                var timeSimulated = NodalAnalysisComplete(y, remainingTime, timeSettings);
                remainingTime -= timeSimulated;
            }
            // Implement in partial
            CalculationStepFinished();
        }

        #region Post-processing

        private void InitPostProcessingData()
        {
            foreach (var p in _pipes)
            {
                foreach (var conn in p.Elements)
                {
                    if (conn.Element is Junction j)
                    {
                        if (!_junctionMap.ContainsKey(j))
                        {
                            _junctionMap.Add(j, new List<Pipe>());
                        }
                        _junctionMap[j].Add(p);
                    }
                }
            }

            if (_junctionMap.Any())
            {
                _junctionMaxConnectionLevel = _junctionMap.Max(j => j.Value.Count);
            }
        }

        public int MaxPostProcessingLoops { get; set; } = 10;

        private int _junctionMaxConnectionLevel = 0;
        private readonly List<IElementBase> _baseElements = new List<IElementBase>();
        private List<Junction> _junctions = new List<Junction>();
        private readonly Dictionary<Junction, List<Pipe>> _junctionMap = new Dictionary<Junction, List<Pipe>>();
        private double NodalAnalysisComplete(double[] y, double requestedDeltaT, SimulatorsBase.TimeSettings timeSettings = null)
        {
            var deltaT = requestedDeltaT;

            // See if we need to reduce the timestep (if allowed)
            if (timeSettings != null && deltaT > timeSettings.MinimumStep.TotalSeconds)
            {
                // Determine allowed timestep size
                _baseElements.ForEach(elm => deltaT = Math.Min(deltaT, elm.DetermineMaxTimestep(y, deltaT)));
            }

            // Limit the step size
            deltaT = timeSettings == null ? deltaT : Math.Max(timeSettings.MinimumStep.TotalSeconds, deltaT);

            // First the "normal" elements (no junctions etc)
            _baseElements.ForEach(elm => elm.UpdateElement(y, deltaT));

            // Very basic deadlock detection
            int loopsLeft = MaxPostProcessingLoops;
            do
            {
                if (loopsLeft-- <= 0) throw new InvalidOperationException("Post-processing step not converging on solution");

                // Pipes with flow defined that still need to be done and could calculate (e.g. don't take flow from uncalculated junction)
                var pipesToCalculate = _pipes.Where(pp => !pp.HasCalculated && pp.IsFlowDefined).ToList();
                foreach (var p in pipesToCalculate)
                {
                    lock(p)
                    {
                        p.UpdateElement(y, deltaT);
                    }
                }

                // Select the "best" junctions to calulcate
                if (_junctions.Count(j => !j.HasCalculated) > 0)
                {
                    List<Junction> junctionsToCalculate;
                    for (int uncalculatedPipes = 0; uncalculatedPipes <= _junctionMaxConnectionLevel; uncalculatedPipes++)
                    {
                        junctionsToCalculate = _junctions.Where(j => !j.HasCalculated && _junctionMap[j].Count(p => !p.HasCalculated) <= uncalculatedPipes).ToList();
                        if (junctionsToCalculate.Count > 0)
                        {
                            foreach (var j in junctionsToCalculate)
                            {
                                j.UpdateElement(y, deltaT);
                            }
                            // Leave the junctions with more unconnected pipes until after the next update of the pipes
                            break;
                        }
                    }
                }
            }
            while (SimComponents.Any(elm => !elm.HasCalculated));

            return deltaT;
        }

        #endregion
    }
}
